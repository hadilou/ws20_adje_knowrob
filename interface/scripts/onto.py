#!/usr/bin/env python3

#ontologiey related
from owlready2 import *
from get_model import *

from utils import *

import roslib
roslib.load_manifest('joint_states_listener')
import rospy
from joint_states_listener.srv import ReturnJointStates
import time
import sys

TOP_CST = 10 # in cm
SIDE_CST = 30 #in cm


#srdl2 = OWLOnto(r'/root/catkin_ws/src/interface/owl/',r'/root/catkin_ws/src/interface/owl/srdl2.owl')
#knowrob = OWLOnto(r'/root/catkin_ws/src/interface/owl/',r'/root/catkin_ws/src/interface/owl/knowrob.owl')
#dul = OWLOnto(r'/root/catkin_ws/src/interface/owl/',r'/root/catkin_ws/src/interface/owl/DUL.owl')
#soma = get_ontology("http://www.ease-crc.org/ont/SOMA.owl").load()
new_onto = get_ontology(r'/root/catkin_ws/src/interface/owl/Tiago.owl')#,r'/root/catkin_ws/src/interface/owl/Tiago.owl')
#tiagoOnto.print_stats()
#tiagoOnto.assert_onto()
#with tiagoOnto.onto:
#   class Tiago(Thing):
#       pass
knowrob_namespace = new_onto.get_namespace("http://ias.cs.tum.edu/kb/knowrob.owl")
soma_namespace = new_onto.get_namespace("http://www.ease-crc.org/ont/SOMA.owl")
srdl2_namespace = new_onto.get_namespace("http://knowrob.org/kb/srdl2.owl")
pr2_namespace = new_onto.get_namespace("http://ias.cs.tum.edu/kb/PR2.owl")
dul_namespace = get_namespace("http://www.ontologydesignpatterns.org/ont/dul/DUL.owl")

#new_onto = get_ontology(r"/root/catkin_ws/src/interface/owl/Tiago.owl")

#new_onto.load()

#add table object to onto

with new_onto:
    
    class PhysicalObject(Thing):pass
    PhysicalObject.comment = ["Any physical object or agent, capable of performing an action or not"]
    class Robot (PhysicalObject):pass
    Robot.comment = ["Any physical agent, capable of performing an action"]
    class Geometric(Thing):pass
    Geometric.comment = ["Geometric data structures"]

    class Manipulation(Thing):pass
    Manipulation.comment = ["Manipulation concept"]

    class Tiago(Robot): pass
    Tiago.comment = ["Tiago robot from pal robotics http://wiki.ros.org/Robots/TIAGo"]
    class Object (PhysicalObject): pass
    Object.comment = ["Any object that can not perform an action like table, can , etc."]
    class Can (Object): pass
    class Table (Object): pass
    class BodyPart(PhysicalObject): pass
    BodyPart.comment = ["A component or part of a robot such as arm,head,..etc"]
    class Arm(BodyPart):pass 
    class Finger(BodyPart):pass
    class Gripper(BodyPart):pass 
    class LiftTorso(BodyPart):pass 
    class MobileBase(BodyPart):pass 
    class Head(BodyPart):pass 
    class Wheels(BodyPart):pass
    class Action(Manipulation):pass
    Action.comment = ["A manipulation task simplied as an action"]
    class Trajectory(Manipulation):pass
    Trajectory.comment = ["Trajectory followed durinfg a task, example of trajectory generated by Moveit"]
    class GraspForce(Manipulation):pass
    class Movement(Manipulation):pass
    Movement.comment = ["Movement of a part during a manipulation task"]
    class DPose (Geometric): 
        def __init__(self,x,y,z):
            self.x = float (x)
            self.y = y
            self.z = z 
    DPose.comment = ["3d pose object"]           
    class SpatialLocation(Geometric):pass
    SpatialLocation.comment = ["Spatial location of an object w.r.t another object in natural language"]
    #class part_of(BodyPart >> Robot, TransitiveProperty): pass
    #lass base_link_of(Thing >> BodyPart, TransitiveProperty): pass
    #lass end_link_of(Thing >> BodyPart, TransitiveProperty): pass

    class Joint(PhysicalObject):pass
    class Link(PhysicalObject):pass
    class has_parent_link(DataProperty,FunctionalProperty):
        domain = [Joint]
        range = [str]
    class has_child_link(DataProperty,FunctionalProperty):
        domain = [Joint]
        range = [str]
    
    class State(Thing):pass
    class has_joint(ObjectProperty):
        domain = [State]
        range = [Joint]
    class has_velocity(DataProperty,FunctionalProperty):
        domain = [State]
        range = [float]
    class has_position(DataProperty,FunctionalProperty):
        domain = [State]
        range = [float]
    class has_acceleration(DataProperty,FunctionalProperty):
        domain = [State]
        range = [float]
    class has_effort(DataProperty,FunctionalProperty):
        domain = [State]
        range = [float]


    class has_height(DataProperty,FunctionalProperty):
        domain = [Object]
        range = [float]
    class has_width(DataProperty,FunctionalProperty):
        domain = [Object]
        range = [float]
    class has_lenght(DataProperty,FunctionalProperty):
        domain = [Object]
        range = [float]
    class hold_pose_x(DataProperty,FunctionalProperty):
        domain = [Object]
        range = [float]
    class hold_pose_y(DataProperty,FunctionalProperty):
        domain = [Object]
        range = [float] 
    class hold_pose_z(DataProperty,FunctionalProperty):
        domain = [Object]
        range = [float]
    class has_spatial_location(DataProperty,FunctionalProperty):
        domain = [Object]
        range = [str]
    #a rectangular area deliminiting a region    
    class Surface(Geometric): 
        def __init__(x,y,w,h):
            self.x = x #upper left x
            self.y = y #upper left y
            self.w = w #width
            self.h = h # height
    class has_grasp_region(ObjectProperty):
        domain = [Object]
        range = [DPose]

    class has_goal(ObjectProperty):
        domain = [Action]
        range = [Object]
    class is_trajectory_of(ObjectProperty):
        domain = [Trajectory]
        range = [Action]
    class has_trajectory(ObjectProperty):
        domain = [Action]
        range = [Trajectory]
        inverse_property = is_trajectory_of

    class affords(ObjectProperty):
        domain = [Robot]
        range = [Action]
    class is_afforded_by(ObjectProperty):
        domain = [Action]
        range = [Robot]
        inverse_property = affords
    class is_used_by(ObjectProperty):
        domain = [GraspForce]
        range = [Action]
    class uses(ObjectProperty):
        domain = [Action]
        range = [GraspForce]
        inverse_property = is_used_by
    class is_participant_of(ObjectProperty):
        domain = [Joint]
        range = [Action]
    class has_participant(ObjectProperty):
        domain = [Action]
        range = [Joint]
        inverse_property = is_participant_of
    class is_movement_of(ObjectProperty):
        domain = [State]
        range = [Action]
    class has_movement(ObjectProperty):
        domain = [Action]
        range = [State]
        inverse_property = is_movement_of


    class is_reachable(DataProperty,FunctionalProperty):
        domain = [Object]
        range = [bool]
    class has_surface(ObjectProperty):
        domain = [Object]
        range = [Surface]   
    class is_available(DataProperty,FunctionalProperty):
        domain = [Object]
        range = [bool]

    class has_payload(DataProperty,FunctionalProperty):
        domain = [Arm]
        range = [float]
    class has_reach(DataProperty,FunctionalProperty):
        domain = [Arm,Finger]
        range = [float]
    class has_Lift(DataProperty,FunctionalProperty):
        domain = [LiftTorso]
        range = [float]
    class has_max_speed(DataProperty,FunctionalProperty):
        domain = [LiftTorso]
        range = [float]

class SpatialReasoner():

    def onTop(self,obj1,obj2):
        ##return 1 if obj1 is on top of obj2
        # get coordinates of objects on Z axis
        # get the obj with highest z (top object)
        # check if diff on z is less than predefined value
        z1 = obj1.hold_pose_z
        z2 = obj2.hold_pose_z
        h2 = obj2.has_height
        if z1>z2:# top from bottom is z1
            if z1-z2-h2 <= TOP_CST: 
                return True
        return False

    def spatialSituation(self,obj1,obj2):
        #return the relative position(left,right) of object
        if self.onTop(obj1,obj2):
            return format(obj1.name) +" top "+ format(obj2.name)
        elif self.onTop(obj2,obj1):
            return format(obj2.name) +" top "+ format(obj1.name)
        elif self.rightTo(obj1,obj2):
            return  format(obj1.name) +" right "+ format(obj2.name)
        elif self.rightTo(obj2,obj1):
            return  format(obj2.name) +" right "+ format(obj1.name)
        elif self.leftTo(obj1,obj2):
            return  format(obj1.name) +" left "+ format(obj2.name)
        elif self.leftTo(obj2,obj1):
            return  format(obj2.name) +" left "+ format(obj1.name)
        else:
            return "Unkwown"

    def inside(self,obj1,obj2):
        #return true if object1 is inside object2
        w1 = obj1.has_width
        w2 = obj2.has_width
        h1 = obj1.has_height
        h2 = obj2.has_height
        l1 = obj1.has_lenght
        l2 = obj2.has_lenght
        x1 = obj1.hold_pose_x
        x2 = obj2.hold_pose_x
        y1 = obj1.hold_pose_y
        y2 = obj2.hold_pose_y

        if w1<w2 and h1<h2: # obj1 can be inside obj2 but it is really inside??
            if x1> x2+w2/2 and x1 < x2-w2/2: # x1 in width range ??
                if y1 > y2 + l2/2 and y1 < y2-l2/2: # y1 in lenght range?
                    return True
        return False


    def rightTo(self,obj1,obj2):
        # diff on x is less than threshold,
        # righter objet has bigger y
        x1 = obj1.hold_pose_x
        x2 = obj2.hold_pose_x
        y1 = obj1.hold_pose_y
        y2 = obj2.hold_pose_y

        if x1-x2 <= SIDE_CST:
            if y1 > y2 :
                return True
        return False
    
    def leftTo(self,obj1,obj2):
        # diff on x is less than threshold,
        # righter objet has bigger y
        x1 = obj1.hold_pose_x
        x2 = obj2.hold_pose_x
        y1 = obj1.hold_pose_y
        y2 = obj2.hold_pose_y

        if x1-x2 <= SIDE_CST:
            if y1 < y2 :
                return True
        return False
    
    def is_reachable(self,onto,robot: Robot,obj:Object) -> bool:
        #check if the robot can reach the object .. is robot reach >= dist(robot,object) ??
        arm = None
        reach = None
        arm = str(onto.search(is_a=new_onto.Arm,part_of=robot)[0])
        reach = onto[arm.split('.')[-1]].has_reach
        base = str(onto.search(is_a=new_onto.MobileBase,part_of=robot)[0])
        robotX = onto[base.split('.')[-1]].hold_pose_x
        robotY = onto[base.split('.')[-1]].hold_pose_y
        robotZ = onto[base.split('.')[-1]].hold_pose_z
        objectX,objectY,objectZ = obj.hold_pose_x,obj.hold_pose_y,obj.hold_pose_z
        d = distance(robotX,robotY,robotZ,objectX,objectY,objectZ)
        if d <= reach :
            return True
        return False
        
def call_return_joint_states(joint_names):
    rospy.wait_for_service("return_joint_states")
    try:
        s = rospy.ServiceProxy("return_joint_states", ReturnJointStates)
        resp = s(joint_names)
    except rospy.ServiceException as e:
        print ("Error when calling return_joint_states: %s"%e)
        sys.exit(1)
    for (ind, joint_name) in enumerate(joint_names):
        if(not resp.found[ind]):
            print ("joint %s not found!"%joint_name)
    return (joint_name,resp.position, resp.velocity, resp.effort)

#pretty-print list to string
def pplist(list):
    return ' '.join(['%2.3f'%x for x in list])

#creating instances
tiago_1 = Tiago("tiago_1")
table_1 = Table("table_1")
cocacola_1 = Can("cocacola_1")
aruco_cube_1 = Object("aruco_cube_1")

#parts of Tiago
tiago_1_Arm = Arm("tiago_1_arm",part_of = [tiago_1],has_payload=3.0,has_reach=0.87)
tiago_1_Gripper = Gripper("tiago_1_gripper",part_of=[tiago_1])
tiago_1_Finger_R = Finger("tiago_1_finger_R",part_of = [tiago_1_Gripper],has_reach=0.044)
tiago_1_Finger_L = Finger("tiago_1_finger_L",part_of = [tiago_1_Gripper],has_reach=0.044)
tiago_1_Torso = LiftTorso("tiago_1_torso",part_of = [tiago_1],has_lift = 0.35)
tiago_1_Base = MobileBase("tiago_1_base",part_of = [tiago_1],has_max_speed = 1)
tiago_1_Head = Head("tiago_1_head",part_of=[tiago_1])
tiago_1_Cam = BodyPart("tiago_1_cam", part_of = [tiago_1_Head])


#set object properties
#listening to gazebo model states topic
rospy.init_node('listener', anonymous=True)
models = ["tiago","table1","aruco_cube","cocacola","beer","closet","tv","lamp","pringles"]
gz_model = GazeboModel(models)

poses = {}
rate = rospy.Rate(1)  # 10hz
are_models_ready = False
while not are_models_ready:
    for model_name in models:
        pose_now = gz_model.get_model_pose(model_name)
        if pose_now != None:
            poses[model_name] = pose_now
        are_models_ready = len(poses) == len(models)
        print("POSE NOW ROBOT =" + model_name + "==>" + str(pose_now))
        print("---")

    rate.sleep()

sr = SpatialReasoner() 

if  are_models_ready:
    cocacola_1.hold_pose_x = (poses["cocacola"].position.x)
    cocacola_1.hold_pose_y = (poses["cocacola"].position.y)
    cocacola_1.hold_pose_z = (poses["cocacola"].position.z)
    table_1.hold_pose_x = (poses["table1"].position.x)
    table_1.hold_pose_y = (poses["table1"].position.y)
    table_1.hold_pose_z = (poses["table1"].position.z)
    tiago_1_Base.hold_pose_x = (poses["tiago"].position.x)
    tiago_1_Base.hold_pose_y = (poses["tiago"].position.y)
    tiago_1_Base.hold_pose_z = (poses["tiago"].position.z)
    table_1.has_height =  (poses["cocacola"].position.z)       

    #spatial relations
    cocacola_1.has_spatial_location = sr.spatialSituation(cocacola_1,table_1)
    table_1.has_spatial_location = sr.spatialSituation(table_1,cocacola_1)
    print(cocacola_1.has_spatial_location)
    print("---")


grasp_task = Action("pick_up_place_task")
grasp_task.is_afforded_by.append(tiago_1)
grasp_task.has_goal.append(aruco_cube_1)

#populating ontology with joint's states
joint_names = ["arm_1_joint",
                "arm_2_joint",
                "arm_3_joint",
                "arm_4_joint",
                "arm_7_joint",
                "arm_5_joint",
                "gripper_right_finger_joint",
                "gripper_left_finger_joint",
                "torso_lift_joint"]

parents_links = ["torso_lift_link",
                "arm_1_link",
                "arm_2_link",
                "arm_3_link",
                "arm_6_link",
                "arm_4_link",
                "None",
                "None",
                "torso_fixed_link"]

child_links = ["arm_1_link",
            "arm_2_link",
            "arm_3_link",
            "arm_4_link",
            "arm_7_link",
            "arm_5_link",
            "None",
            "None",
            "torso_fixed_link"]


joints = {}
for idk,joint_name in enumerate(joint_names):
    #set up joints objects and their child and base links
    joints[joint_name] = Joint(joint_name)
    joints[joint_name].has_child_link = child_links[idk]
    joints[joint_name].has_parent_link = parents_links[idk]
    grasp_task.has_participant.append(joints[joint_name])


#processing joints 
counter = 1
states = []



while(1 and counter <20 ):
    for joint_name in joint_names:
        (name,position, velocity, effort) = call_return_joint_states([joint_name])
        print ("Joint name:",name)
        print ("position:", pplist(position))
        print ("velocity:", pplist(velocity))
        print ("effort:", pplist(effort))
        time.sleep(1)
        print("---")
        #save to ontology
        state = State("state_"+str(counter))
        state.has_joint.append(joints[joint_name])
        state.has_position = position[0]
        state.has_effort = effort[0]
        state.has_velocity = velocity[0]
        state.is_movement_of.append(grasp_task)
        counter+=1


# auto-classify and save the ontology(only modifications made in python here are saved)
with new_onto:
    print("\n\n Starting OWL Reasoner")
    sync_reasoner()
new_onto.save(file = "/root/catkin_ws/src/ws20_adje_knowrob/interface/owl/Tiago_inf.owl",format="rdfxml")
